title: ulimitの説明　と　セグメンテーション違反
date: 2015-02-26 09:27:54
tags: linux開発
---

##はじめに
linux Cを開発する時、セグメンテーション違反はよく見えるよね（すげーSE者とPG者を除外）。その時は解決しないといけないだろう。その原因はいつもポインタのせいだと思う。

##一、ulimitにおいて簡単な説明
でも、環境の問題があるという言い方も存在する(ネットで調べた結果）。例えば、ローカル変数で11MBを使っているが、linuxのデフォルトのスタックサイズは10MBの場合、スタックオーバーフローになってしまうのだ。どのように現在使っている環境のデフォルトスタックサイズを確認できるか？今から説明する。

現在の環境を確認しようと思ったら、ulimitを使って、目的を達成できる。ulimitに関しては、以下のように使える：
<pre><code>
-a	設定されている各種の制限を表示する
-c	プロセスがファイルへコア・ダンプする容量を最大Nブロックに制限する
-d	プロセスのデータ領域のサイズを最大Nキロ・バイトに制限する
-f	出力ファイルのサイズを最大Nブロックに制限する
-l	メモリーにロックできるサイズを最大Nキロ・バイトに制限する
-m	メモリーの使用量を最大Nキロ・バイトに制限する
-n	ファイル・ディスクリプタの数を最大N個に制限する
-p	パイプのサイズを最大N×512バイトに制限する
-s	スタック・サイズを最大Nキロ・バイトに制限する
-t	CPU時間を最大N秒に制限する
-u	ユーザー1人が起動できるプロセス数を最大N個に制限する
-v	シェルが利用できる仮想メモリーを最大Nキロ・バイトに制限する
-H	いったん設定した制限を解除できなくする
-S	-Hで制限した最大値以内の値を設定する
-t	コマンドの型を表示する
</code></pre>

もしスタックサイズを調べてほしいなら、「ulimit -s」を入力すればいい。
もしスタックサイズを設定してほしい場合、「ulimit -s SIZE」を入力する（SIZEは設定したがるサイズである）
注意するべき点は、この設定したら、今の実行中shellしか効かない。もしシステム全体に効くように設定しようと、/etc/profileに先のコマンドを入力するべきだ。(shellで echo ulimit -s 1024を入力してもいい）。

##二、セグメンテーション違反
セグメンテーション違反はC言語のPG者たちに対して、とても厄介なものといっても過言ではない(No1ではないね）。
このエラーの原因はいくつある、現在思い出せる原因を挙げましょう：
①スタックの領域が足りない。
この原因は理解しやすい。スタックが足りない場合、つまり、スタックオーバーフローになってしまう。
一つ例を挙げろ：

```C
int main()
{
	main();
	return 0;
}
```

上の例により、無限ループで関数を呼び出すと、スタックが足りないので、セグメンテーション違反になる。

②アプリは使えないアドレスを使おうとする。
例えば、

```C
int *p = NULL;
*p = 4;
```

C言語では、NULL = (void *)0、ソースはそうなったら、アドレス０の内容を変更しようと、エラー発生する。

③変更できない内容を変更しよう
また例を挙げましょう：

```C
char *p = "Hello core";
p[0] = 'm';
```

上の用なソースを実行したら、定数をかえようと、セグメンテーション違反が発生する。

##三、セグメンテーション違反のデバッグ
①gdbでデバッグ：
linuxには最初からgdbがインストールされた場合がおおいから、セグメンテーション違反が発生する場合、gdbで調査できる。
例えば、a.out実行するとエラーが発生する場合、[gdb a.out]を入力し、gdbでデバッグを開始させる。それで、「run」を実行すると、実行ファイルが動いている。セグメンテーション違反発生時、デバッグは一旦停止し、どこで止まっているのかが出力された。そうすると、どこが問題なのかをわかっているかもしれない。

gdbでデバッグはcoreファイルを使って、デバッグもできる。普通にはセグメンテーション違反の場合、core dumpファイルが作成される。（windows アプリと似ている。ウィンドウズでは、デバッグ時、mapファイルとsymbolファイルを事前に作成し、アプリが落ちる場合、dumpファイルも作成される。自動的作成されることがあるかもしれない、もし作成されていない場合、落ちる画面を閉じないままで、タスク管理でアプリの項目を右クリックして、ダンプファイルを作成を選択し、ダンプファイルが作成される）。coreファイルが作成された場合、「gdb core」を入力すると、問題を解けるかもしれない。でも、coreファイルは自動作成できない場合がおおい。その原因はcoreファイルのサイズはデフォルト値０に設定されたから。もしcoreファイルを作成しようと思ったら、前のulimitを使って、「ulimit -c 1024」設定してからcoreファイルが自動的に作成される。

②backtrace()とobjdumpを使って、セグメンテーション違反場所を探す。
この方法はちゃんと見ていないので、後回す


ps:
不具合調査するときは、「objdump」と「nm」コマンドも使っていた。
-rdynamic 全部フラグをダイナミックフラグとしてフラグ表に入れる。
[他の場所見つからなかったので、中国語で説明]g++ 加上 -rdynamic 参数实质上相当于ld链接的时候加上-E或者–export-dynamic参数，效果与g++ -Wl,-E或者g++ -Wl,–export-dynamic的效果是一样的。

-gdb補充：
`x' というコマンド (`examine' からの由来) は、プログラムのデータ 型を参照せずにメモリを調べるときに使うことができます。あなたが調べたい メモリのフォーマットは、系統だった方法で記述されます。許可されている フォーマットは、以前の章で述べてきたフォーマットのスーパーセットに なっています。

`x' はスラッシュの後にフォーマットに関する記述、そしてその後に アドレスに関する記述を受け付けます。式には (もし通したとしても) ポインタ 値が使えないので; そこにはメモリのバイト列の整数値やアドレスが使われます。 式の詳細は、See section 式。 例えば、`x/4xw $sp' はスタックポインタ上のメモリを4ワードの 16進数で表示します。

このケースにおける出力フォーマットでは、調査するメモリの大きさと、 そのユニットの内容をどのように表示するのかということを記述します。 これには、この後に説明する1つか2つの文字で指定します:

次に示す文字は、まさに調査対象のユニットのサイズを記述します:

`b'
単一バイトで調査します。
`h'
半ワード (2バイト) で調査します。
`w'
ワード (4バイト) で調査します。 多くのアセンブラとCPU設計者は、祖先となる1970年代のマシンが実際に 2バイトのワードを利用していたという名残により、`ワード'をいまだ 16ビットのサイズとして定義しています。しかし、一般的に言うと、 `ワード'は、マシンが通常レジスタで操作したり記憶したりするサイズだと いうのが、語源です。GDB が動作する全てのマシンにおいて、このサイズは 32ビットです。
`g'
巨大ワード (8バイト) で調査します。
次の文字は内容を表示する方法を記述するためのものです:

`x'
符号なし16進整数値で表示します。
`d'
符号付き10進整数値で表示します。
`u'
符号なし10進整数値で表示します。
`o'
符号なし8進整数値で表示します。
`a'
絶対アドレス、またはシンボルに定義された相対アドレスで表示します。
`c'
文字定数で表示します。
`f'
浮動小数点で表示します。これは、`w' と `g' のサイズでのみ 有効です。
`s'
null-ターミネートされた文字列として表示します。指定されたユニットサイズは 無視され; かわりに null キャラクタまで達する多くの (null キャラクタを含んだ) バイト 列を持つことになります。
`i'
アセンブラ・シンタックスでの (もしくは、それに近い) マシン・ インストラクションを表示します。指定されたユニットサイズは無視され; 1つのインストラクションを構成するバイト数は、そのマシンで利用されている オペコードとアドレッシングモードの種類に依存します。
表示方法やユニットサイズの指定がなかった場合、使用されるデフォルト値は 最後に使用されたのと同じものです。もし、あなたがスラッシュの後に何の 文字も使用したくないという場合は、スラッシュもまた省略できます。

あなたは、また、調査対象アドレスも省略可能です。この場合、ユニットが 最後に調査されたアドレスが使用されます。これは、データをベースとして ユニットサイズが計算されるような、文字列とインストラクション・ フォーマットのためのものです: というのも、次の文字列やインストラクションは正しい位置から調査を 開始しなければならないからです。`print' コマンドは、時折 `x' コマンドのためのデフォルトアドレスを設定します; メモリ上に位置する値が表示された時、デフォルトで同一の 位置が設定されています。`info line' はまた `x' と同様に 指定された行のマシンコードの開始アドレスにデフォルトを設定し、 `info breakpoints' は、最後に表示されたブレークポイントの アドレスにデフォルトを設定します。

RET により `x' コマンドがリピートされた時は全く同様の内容を リピートしません: 指定されたアドレスは (もしあれば) 無視され、リピートされたコマンドは 同一の場所のかわりに連続したメモリ位置を調査します。

あなたは、更に、コマンドに対してスラッシュの後に (また、もしあれば フォーマット文字の前に) 繰り返し回数を書くことで、いくつかの連続的な メモリユニットを調査することができます。繰り返し回数は10進数の整数で なければなりません。これは、`x' コマンドがリピートされた時と 同様な効果を持ち、出力は行ごとのいくつかのユニットに対して、より コンパクトになります。例えば、

x/10i $pc
は、選択されているフレームにおいて次に実行されるインストラクションから 10個のインストラクションを表示します。この後、あなたは、次のように入力 することで、更に10個のインストラクションを表示できます。

x/10
これは、フォーマットとアドレスにおいてデフォルト値が使われるからです。

`x' コマンドによって表示されるアドレスとその内容は、それらが あまりにも多すぎ、それらを記録するのが邪魔なので、変数履歴に代入 されません。そのかわりに、GDB は、簡易変数 $_ と $__ の 値を式で使うという別な手段を提供しています。

`x' コマンドの後、最後に調査されたアドレスは、 式内の簡易変数 $_ によって参照可能となります。そのアドレスの 内容は、調査されたならば、簡易変数 $__ においても有効です。

もし、`x' コマンドが繰り返されたならば、アドレスと内容は最後に 表示されたメモリユニットの形態として保存されます; これは、最後の行の出力においていくつかのユニットが表示された時の 最後のアドレス表示の内容とは異なります。

`disassemble' という特別なコマンドは、与えられたメモリレンジを マシン・インストラクションとしてダンプします。デフォルトのメモリ レンジは、選択されているフレーム上のプログラムカウンタを取り囲む 関数の範囲です。このコマンドへ一つの引数を渡した場合、これは、 プログラムカウンタ値となります; この値を取り囲む関数がダンプされます。2つの引数を渡した場合は、 ダンプするアドレスの範囲を示します。(最初が包括的、2つ目が排他的。)


