title: C++反汇编与逆向分析技术揭秘(1)--float format
date: 2015-03-05 09:42:29
tags: Read Tech
---

今日は＜＜C++反汇编与逆向分析技术揭秘＞＞を見たところ、floatに関するものを復習した。
float型からint型に強制変換するときは小数を捨てることを覚えだした。
その中、気になっているのはMicrosoft Visual C++6.0で小数型のデータを定義しないと、それに対してのレジスタは初期化されない。以下のソースを見て下さい：


```C
int main(void)
{
	int nInt = 0;
	scanf("%f", &nInt);
	return 0;
}
```

資料に書いてあるのは、Microsoft Visual C++6.0でこのプログラムにfloat型の変数は定義されていないため、小数を入力したら、プログラムは落ちる。私はlinuxでgccを使ってビルドして実行すると、落ちていないけど、入力したfloatかたの内容はメモリに保存した状態のままで、int型として出力されていた。

以下のソースも見てください：

```C
#include <stdio.h>

int main(int argc, char *argv[])
{
	int a = 0;

	float b = 5.3;
	float c = 5.6;
	float d = -5.3;
	float e = -5.6;

	scanf("%f", &a);

	printf("%x\n", a);

	printf("(int)b:%d\n", (int)b);
	printf("(int)c:%d\n", (int)c);
	printf("(int)d:%d\n", (int)d);
	printf("(int)e:%d\n", (int)e);

	printf("b:%d\n", b);
	printf("c:%d\n", c);
	printf("d:%d\n", d);
	printf("e:%d\n", e);

	return 0;
}
```

その結果は
<pre><code>
	[root@localhost floatinit]# ./float
	3.5
	40600000
	(int)b:5
	(int)c:5
	(int)d:-5
	(int)e:-5
	b:1073741824
	c:1610612736
	d:1073741824
	e:1610612736
</code></pre>

ちなみに、float型をメモリに保存する時のフォーマットを書いとく：
1bit:正数・負数フラグ
8bit:乗数
23bit:小数

例を上げましょう：
例えば3.5
3 -> 11(b)
0.5の計算方は：0.5 * 2 = 1.0   1
だから、0.5 -> 0.1(b)
もし0.25の場合：0.25 * 2 = 0.5  0
0.5 * 2 = 1.0 1
だから、0.25 -> 0.01(b)

3.5 -> 11.1(b) = 1.11(b) * 2の1乗数
正数のため、1bitは0;
乗数の方は:<127の場合、乗数は負数とみなす。
だから、3.5の場合、乗数は 127 + 1 -> 1000 0000
小数の方は：23bit足りない場合、0を後ろで埋め尽くす。
だから、3.5の場合は、1100000 00000000 00000000

その３つを組み合わせたら、0 1000 0000 1100000 00000000 00000000
16進数に変換すると、
0100 0000 0110 0000 0000 0000 0000 0000
0x 4    0    6    0    0    0    0    0

double型のフォーマットとfloatはだいたい同じけど、ただ精度は高くなる
1bit:正数・負数フラグ
11bit:乗数(+1023なら、正数・負数を判断できる)
42bit:小数

ps1:float型からint型に変換時、_ftol()関数は呼び出されること。
  

ps2:＜＜C++反汇编与逆向分析技术揭秘＞＞この本はVisual C++6.0をベースに説明したけど、この本から勉強した内容を持って、自分でlinux上のものを理解できると思う。
