title: ulimitの説明　と　セグメンテーション違反
date: 2015-02-25 15:55:54
tags: linux
---

##はじめに
linux Cを開発する時、セグメンテーション違反はよく見えるよね（すげーSE者とPG者を除外）。その時は解決しないといけないだろう。その原因はいつもポインタのせいだと思う。

##一、ulimitにおいて簡単な説明
でも、環境の問題があるという言い方も存在する(ネットで調べた結果）。例えば、ローカル変数で11MBを使っているが、linuxのデフォルトのスタックサイズは10MBの場合、スタックオーバーフローになってしまうのだ。どのように現在使っている環境のデフォルトスタックサイズを確認できるか？今から説明する。

現在の環境を確認しようと思ったら、ulimitを使って、目的を達成できる。ulimitに関しては、以下のように使える：
<pre><code>
-a	設定されている各種の制限を表示する
-c	プロセスがファイルへコア・ダンプする容量を最大Nブロックに制限する
-d	プロセスのデータ領域のサイズを最大Nキロ・バイトに制限する
-f	出力ファイルのサイズを最大Nブロックに制限する
-l	メモリーにロックできるサイズを最大Nキロ・バイトに制限する
-m	メモリーの使用量を最大Nキロ・バイトに制限する
-n	ファイル・ディスクリプタの数を最大N個に制限する
-p	パイプのサイズを最大N×512バイトに制限する
-s	スタック・サイズを最大Nキロ・バイトに制限する
-t	CPU時間を最大N秒に制限する
-u	ユーザー1人が起動できるプロセス数を最大N個に制限する
-v	シェルが利用できる仮想メモリーを最大Nキロ・バイトに制限する
-H	いったん設定した制限を解除できなくする
-S	-Hで制限した最大値以内の値を設定する
-t	コマンドの型を表示する
</code></pre>

もしスタックサイズを調べてほしいなら、「ulimit -s」を入力すればいい。
もしスタックサイズを設定してほしい場合、「ulimit -s SIZE」を入力する（SIZEは設定したがるサイズである）
注意するべき点は、この設定したら、今の実行中shellしか効かない。もしシステム全体に効くように設定しようと、/etc/profileに先のコマンドを入力するべきだ。(shellで echo ulimit -s 1024を入力してもいい）。

##二、セグメンテーション違反
セグメンテーション違反はC言語のPG者たちに対して、とても厄介なものといっても過言ではない(No1ではないね）。
このエラーの原因はいくつある、現在思い出せる原因を挙げましょう：
①スタックの領域が足りない。
この原因は理解しやすい。スタックが足りない場合、つまり、スタックオーバーフローになってしまう。

②アプリは使えないアドレスを使おうとする。
例えば、

```C
int *p = NULL;
*p = 4;
```

C言語では、NULL = (void *)0、ソースはそうなったら、アドレス０の内容を変更しようと、エラー発生する。

③変更できない内容を変更しよう
また例を挙げましょう：

```C
char *p = "Hello core";
p[0] = 'm';
```

上の用なソースを実行したら、定数をかえようと、セグメンテーション違反が発生する。

##三、セグメンテーション違反のデバッグ
①gdbでデバッグ：
linuxには最初からgdbがインストールされた場合がおおいから、セグメンテーション違反が発生する場合、gdbで調査できる。
例えば、a.out実行するとエラーが発生する場合、[gdb a.out]を入力し、gdbでデバッグを開始させる。それで、「run」を実行すると、実行ファイルが動いている。セグメンテーション違反発生時、デバッグは一旦停止し、どこで止まっているのかが出力された。そうすると、どこが問題なのかをわかっているかもしれない。

gdbでデバッグはcoreファイルを使って、デバッグもできる。普通にはセグメンテーション違反の場合、core dumpファイルが作成される。（windows アプリと似ている。ウィンドウズでは、デバッグ時、mapファイルとsymbolファイルを事前に作成し、アプリが落ちる場合、dumpファイルも作成される。自動的作成されることがあるかもしれない、もし作成されていない場合、落ちる画面を閉じないままで、タスク管理でアプリの項目を右クリックして、ダンプファイルを作成を選択し、ダンプファイルが作成される）。coreファイルが作成された場合、「gdb core」を入力すると、問題を解けるかもしれない。でも、coreファイルは自動作成できない場合がおおい。その原因はcoreファイルのサイズはデフォルト値０に設定されたから。もしcoreファイルを作成しようと思ったら、前のulimitを使って、「ulimit -c 1024」設定してからcoreファイルが自動的に作成される。

②backtrace()とobjdumpを使って、セグメンテーション違反場所を探す。
この方法はちゃんと見ていないので、後回す


ps:
不具合調査するときは、「objdump」と「nm」コマンドも使っていた。


